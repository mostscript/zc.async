========
Partials
========

What if you want to persist a reference to the method of a persistent
object--you can't persist that normally in the ZODB, but that can be
very useful, especially to store asynchronous calls.  What if you want
to act on the result of an asynchronous call that may be called later? 
The zc.async package offers an approach modelled loosely on the Twisted
deferred code: `zc.async.partial.Partial`.  To use it, simply wrap the
callable--a method of a persistent object or a callable persistent
object or a global function--in the partial.  You can include ordered
and keyword arguments to the partial, which may be persistent objects or
simply pickleable objects.

Unlike a normal partial, the result of the wrapped call goes on the
partial's 'result' attribute, and the immediate return of the call might
not be the end result.  It could also be a failure, indicating an
exception; or another partial, indicating that we are waiting to be
called back by the second partial; or a twisted deferred, indicating
that we are waiting to be called back by a twisted Deferred (see the
`twist` module, also in this package).  After you have the partial, you
can then use a number of methods and attributes on the partial for
further set up.  Let's show the most basic use first, though.

Note that, even though this looks like an interactive prompt, all
functions and classes defined in this document act as if they were
defined within a module.  Classes and functions defined in an interactive
prompt are normally not picklable, and the async Partial must work with
picklable objects [#set_up]_.

    >>> import zc.async.partial
    >>> def call():
    ...     print 'hello world'
    ...     return 'my result'
    ...
    >>> p = root['p'] = zc.async.partial.Partial(call)
    >>> import transaction
    >>> transaction.commit()

Now we have a partial [#verify]_.  We can see that the state is PENDING,
call it, and then see that the function was called, and see the result on
the partial.

    >>> import zc.async.interfaces
    >>> p.state == zc.async.interfaces.PENDING
    True
    >>> res = p()
    hello world
    >>> p.result
    'my result'
    >>> p.state == zc.async.interfaces.COMPLETED
    True

The result of the partial also happens to be the end result of the call,
but as mentioned above, the partial may return a deferred or another partial.

    >>> res
    'my result'

We can also use a method of a persistent object.  Imagine we have a ZODB
root that we can put objects in to.

    >>> import persistent
    >>> class Demo(persistent.Persistent):
    ...     counter = 0
    ...     def increase(self, value=1):
    ...         self.counter += value
    ...
    >>> demo = root['demo'] = Demo()
    >>> demo.counter
    0
    >>> p = root['p'] = zc.async.partial.Partial(demo.increase)
    >>> transaction.commit()
    >>> p() # result is None
    >>> demo.counter
    1

So our two calls so far have returned direct successes.  This one returns
a failure, because the wrapped call raises an exception.

    >>> def callFailure():
    ...     raise RuntimeError('Bad Things Happened Here')
    ...
    >>> p = root['p'] = zc.async.partial.Partial(callFailure)
    >>> transaction.commit()
    >>> res = p()
    >>> p.result
    <twisted.python.failure.Failure exceptions.RuntimeError>

These are standard twisted Failures, except that frames in the stored
traceback have been converted to reprs, so that we don't keep references
around when we pass the Failures around (over ZEO, for instance)
[#no_live_frames]_.  This doesn't stop us from getting nice tracebacks,
though.

    >>> print p.result.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    exceptions.RuntimeError: Bad Things Happened Here

Note that all calls can return a failure explicitly, rather than raising
an exception that the partial converts to an exception.  However, there
is an important difference in behavior.  If a wrapped call raises an
exception, the partial aborts the transaction; but if the wrapped call
returns a failure, no abort occurs.  Wrapped calls that explicitly return
failures are thus responsible for any necessary transaction aborts.  See
the footnote for an example [#explicit_failure_example]_.

Now let's return a partial.  This generally represents a result that is waiting
on another asynchronous persistent call, which would normally be called by
a worker.  We'll fire the second call ourselves for this demonstration.

    >>> def innerCall():
    ...     return 42
    ...
    >>> ip = root['ip'] = zc.async.partial.Partial(innerCall)
    >>> def callPartial():
    ...     return ip
    ...
    >>> p = root['p'] = zc.async.partial.Partial(callPartial)
    >>> transaction.commit()
    >>> res = p()
    >>> res is ip
    True

While we are waiting for the result, the state is ACTIVE.

    >>> p.state == zc.async.interfaces.ACTIVE
    True

When we call the inner partial, the result will be placed on the outer partial.

    >>> p.result # None
    >>> res = ip()
    >>> p.result
    42
    >>> p.state == zc.async.interfaces.COMPLETED
    True

This is accomplished with callbacks, discussed below in the Callbacks_ section.

Now we'll return a deferred.  The story is almost identical to the
partial story, except that, in our demonstration, we must handle
transactions, because the deferred story uses the `twist` module in
this package to let the Twisted reactor communicate safely with the
ZODB: see twist.txt for details.

    >>> import twisted.internet.defer
    >>> inner_d = twisted.internet.defer.Deferred()
    >>> def callDeferred():
    ...     return inner_d
    ...
    >>> p = root['p2'] = zc.async.partial.Partial(callDeferred)
    >>> transaction.commit()
    >>> res = p()
    >>> res is inner_d
    True
    >>> p.state == zc.async.interfaces.ACTIVE
    True
    >>> p.result # None

After the deferred receives its result, we need to sync our connection to see
it.

    >>> inner_d.callback(42)
    >>> p.result # still None; we need to sync our connection to see the result
    >>> p.state == zc.async.interfaces.ACTIVE # it's completed, but need to sync
    True
    >>> trans = transaction.begin() # sync our connection
    >>> p.result
    42
    >>> p.state == zc.async.interfaces.COMPLETED
    True

As the last step in looking at the basics, let's look at passing arguments
into the partial.  They can be persistent objects or generally picklable
objects, and they can be ordered or keyword arguments.

    >>> class PersistentDemo(persistent.Persistent):
    ...     def __init__(self, value=0):
    ...         self.value = value
    ...
    >>> root['demo2'] = PersistentDemo()
    >>> import operator
    >>> def argCall(ob, ob2=None, value=0, op=operator.add):
    ...     for o in (ob, ob2):
    ...         if o is not None:
    ...             o.value = op(o.value, value)
    ...
    >>> p = root['p3'] = zc.async.partial.Partial(
    ...     argCall, root['demo2'], value=4)
    >>> transaction.commit()
    >>> p()
    >>> root['demo2'].value
    4

And, of course, this is a partial: we can specify some arguments when the
partial is made, and some when it is called.

    >>> root['demo3'] = PersistentDemo(10)
    >>> p = root['p3'] = zc.async.partial.Partial(
    ...     argCall, root['demo2'], value=4)
    >>> transaction.commit()
    >>> p(root['demo3'], op=operator.mul)
    >>> root['demo2'].value
    16
    >>> root['demo3'].value
    40

This last feature makes partials possible to use for callbacks: our next
topic.

Callbacks
---------

The partial object can also be used to handle return values and
exceptions from the call.  The `addCallbacks` method enables the
functionality.  Its signature is (success=None, failure=None).  It may
be called multiple times, each time adding a success and/or failure
callable that takes an end result: a value or a zc.async.Failure object,
respectively.  Failure objects are passed to failure callables, and
any other results are passed to success callables.

The return value of the success and failure callables is
important for chains and for determining whether a partial had any
errors that need logging, as we'll see below.  The call to
`addCallbacks` returns a partial, which can be used for chaining (see
`Chaining Callbacks`_).

Let's look at a simple example.

    >>> def call(*args):
    ...     res = 1
    ...     for a in args:
    ...         res *= a
    ...     return res
    ...
    >>> def callback(res):
    ...     return 'the result is %r' % (res,)
    ...
    >>> p = root['p4'] = zc.async.partial.Partial(call, 2, 3)
    >>> p_callback = p.addCallbacks(callback)
    >>> transaction.commit()
    >>> res = p(4)
    >>> p.result
    24
    >>> res
    24
    >>> p_callback.result
    'the result is 24'

We can now introduce another new concept: unhandled errors. A partial
with a failure is considered to have an unhandled error if any leaf-node
callback has a failure result, or if it itself has a failure result and
has no callbacks.  This convention, if followed, can be used to
determine whether to highlight the partial as an error in logs or other
situations.  However, it is only a convention as far as the partial is
concerned (other elements of the zc.async package may treat it more
seriously).

    >>> p.unhandled_error
    False
    >>> def error():
    ...     raise RuntimeError('Boo!')
    ...
    >>> p = root['p3'] = zc.async.partial.Partial(error)
    >>> transaction.commit()
    >>> f = p()
    >>> p.result
    <twisted.python.failure.Failure exceptions.RuntimeError>
    >>> p.unhandled_error
    True
    >>> def handleRuntime(f):
    ...     f.trap(RuntimeError)
    ...
    >>> p_callback = p.addCallbacks(failure=handleRuntime)
    >>> p_callback.state == zc.async.interfaces.COMPLETED
    True
    >>> p_callback.result # None
    >>> p_callback.unhandled_error
    False
    >>> p.unhandled_error
    False

Here are some callback examples adding a success and a failure
simultaneously.  This one causes a success...

    >>> def multiply(first, second, third=None):
    ...     res = first * second
    ...     if third is not None:
    ...         res *= third
    ...     return res
    ...
    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 3)
    >>> transaction.commit()
    >>> def success(res):
    ...     print "success!", res
    ...
    >>> def failure(f):
    ...     print "failure.", f
    ...
    >>> p.addCallbacks(success, failure) # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>
    >>> res = p()
    success! 15

...and this one a failure.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, None)
    >>> transaction.commit()
    >>> p.addCallbacks(success, failure) # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>
    >>> res = p() # doctest: +ELLIPSIS
    failure. [Failure instance: Traceback: exceptions.TypeError...]

you can also add multiple callbacks.

    >>> def also_success(val):
    ...     print "also a success!", val
    ...
    >>> def also_failure(f):
    ...     print "also a failure.", f
    ...
    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 3)
    >>> transaction.commit()
    >>> p.addCallbacks(success) # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>
    >>> p.addCallbacks(also_success) # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>
    >>> res = p()
    success! 15
    also a success! 15

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, None)
    >>> transaction.commit()
    >>> p.addCallbacks(failure=failure) # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>
    >>> p.addCallbacks(failure=also_failure) # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>
    >>> res = p() # doctest: +ELLIPSIS
    failure. [Failure instance: Traceback: exceptions.TypeError...]
    also a failure. [Failure instance: Traceback: exceptions.TypeError...]

Chaining Callbacks
------------------

Sometimes it's desirable to have a chain of callables, so that one callable
effects the input of another.  The returned partial from addCallables can
be used for that purpose.  Effectively, the logic for addCallables is this:

    def success_or_failure(success, failure, res):
        if zc.async.interfaces.IFailure.providedBy(res):
            if failure is not None:
                res = failure(res)
        elif success is not None:
            res = success(res)
        return res

    class Partial(...):
        ...
        def addCallbacks(self, success=None, failure=None):
            if success is None and failure is None:
                return
            res = Partial(success_or_failure, success, failure)
            self.callbacks.append(res)
            return res

Here's a simple chain, then.  We multiply 5 * 3, then that result by 4, then
print the result in the `success` function.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 3)
    >>> transaction.commit()
    >>> p.addCallbacks(zc.async.partial.Partial(multiply, 4)
    ...               ).addCallbacks(success) # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>
    >>> res = p()
    success! 60

A less artificial use case is to handle errors (like try...except) or do
cleanup (like try...finally).  Here's an example of handling errors.

    >>> def handle_failure(f):
    ...     return 0
    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, None)
    >>> transaction.commit()
    >>> p.addCallbacks(
    ...     failure=handle_failure).addCallbacks(success) # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>
    >>> res = p()
    success! 0

If you recall our discussion of unhandled errors above, then you know
this means that even though the top partial has a failure, unhandled_error
is False.

    >>> isinstance(p.result, twisted.python.failure.Failure)
    True
    >>> p.unhandled_error
    False

Callbacks on Completed Partial
------------------------------

When you add a callback to a partial that has been completed, it is performed
immediately.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 2)
    >>> transaction.commit()
    >>> res = p()
    >>> p.result
    10
    >>> p.state == zc.async.interfaces.COMPLETED
    True
    >>> p_callback = p.addCallbacks(zc.async.partial.Partial(multiply, 3))
    >>> p_callback.result
    30
    >>> p.state == zc.async.interfaces.COMPLETED
    True

Chaining Partials
-----------------

It's also possible to achieve a somewhat similar pattern by using a
partial as a success or failure callable, and then add callbacks to the
second partial.  This differs from the other approach in that you are only
adding callbacks to one side, success or failure, not the effective
combined result.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 3)
    >>> transaction.commit()
    >>> p_callback = p.addCallbacks(success)
    >>> p2 = zc.async.partial.Partial(multiply, 4)
    >>> p_callback_2 = p.addCallbacks(p2)
    >>> p_callback_3 = p2.addCallbacks(also_success)
    >>> res = p()
    success! 15
    also a success! 60

This can be used to handle failures, to some degree.

    >>> def handle_failure(f):
    ...     return 0
    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, None)
    >>> transaction.commit()
    >>> p_callback = p.addCallbacks(failure=failure)
    >>> p2 = zc.async.partial.Partial(handle_failure)
    >>> p_callback_2 = p.addCallbacks(failure=p2)
    >>> p_callback_3 = p2.addCallbacks(success)
    >>> res = p() # doctest: +ELLIPSIS
    failure. [Failure instance: Traceback: exceptions.TypeError...]
    success! 0

Failing
-------

Speaking again of failures, it's worth discussing two other aspects of
failing.  One is that partials offer an explicit way to fail a call.  It can
be called when the partial is in PENDING or ACTIVE states.  The primary use
cases for this method are to cancel a partial that is overdue to start, and
to cancel a partial that was in progress by a worker when the worker died
(more on that below).

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 2)
    >>> transaction.commit()
    >>> p.fail()
    >>> print p.result.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    zc.async.interfaces.AbortedError:

`fail` calls all failure callbacks with the failure.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 2)
    >>> p_callback = p.addCallbacks(failure=failure)
    >>> transaction.commit()
    >>> res = p.fail() # doctest: +ELLIPSIS
    failure. [Failure instance: Traceback...zc.async.interfaces.AbortedError...]

As seen above, it fails with zc.async.interfaces.AbortedError by default.
You can also pass in a different error.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 2)
    >>> transaction.commit()
    >>> p.fail(RuntimeError('failed'))
    >>> print p.result.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    exceptions.RuntimeError: failed

As mentioned, if a worker dies when working on an active task, the active task
should be aborted using `fail`, so the method also
works if a partial is in the ACTIVE state.  We'll reach under the covers
to show this.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 2)
    >>> p._state = zc.async.interfaces.ACTIVE
    >>> transaction.commit()
    >>> p.fail()
    >>> print p.result.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    zc.async.interfaces.AbortedError:

It won't work for failing tasks in COMPLETED or CALLBACKS state.

    >>> p.fail()
    Traceback (most recent call last):
    ...
    BadStateError: can only call fail on a partial in PENDING or ACTIVE states
    >>> p._state = zc.async.interfaces.CALLBACKS
    >>> p.fail()
    Traceback (most recent call last):
    ...
    BadStateError: can only call fail on a partial in PENDING or ACTIVE states

Using `resumeCallbacks`
-----------------------

So `fail` is the proper way to handle an active partial that was being
worked on by a dead worker, but how does one handle a partial that was in the
CALLBACKS state?  The answer is to use resumeCallbacks.  Any partial that is
still pending will be called; any partial that is active will be failed;
any partial that is in the middle of calling its own callbacks will have its
`resumeCallbacks` called; and any partial that is completed will be ignored.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 2)
    >>> p._result = 10
    >>> p._state = zc.async.interfaces.CALLBACKS
    >>> completed_p = zc.async.partial.Partial(multiply, 3)
    >>> callbacks_p = zc.async.partial.Partial(multiply, 4)
    >>> callbacks_p._result = 40
    >>> callbacks_p._state = zc.async.interfaces.CALLBACKS
    >>> sub_callbacks_p = callbacks_p.addCallbacks(
    ...     zc.async.partial.Partial(multiply, 2))
    >>> active_p = zc.async.partial.Partial(multiply, 5)
    >>> active_p._state = zc.async.interfaces.ACTIVE
    >>> pending_p = zc.async.partial.Partial(multiply, 6)
    >>> for _p in completed_p, callbacks_p, active_p, pending_p:
    ...     p.callbacks.put(_p)
    ...
    >>> transaction.commit()
    >>> res = completed_p(10)
    >>> p.resumeCallbacks()
    >>> sub_callbacks_p.result
    80
    >>> sub_callbacks_p.state == zc.async.interfaces.COMPLETED
    True
    >>> print active_p.result.getTraceback()
    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    zc.async.interfaces.AbortedError:
    >>> active_p.state == zc.async.interfaces.COMPLETED
    True
    >>> pending_p.result
    60
    >>> pending_p.state == zc.async.interfaces.COMPLETED
    True

Introspecting and Mutating Arguments
------------------------------------

Partial arguments can be introspected and mutated.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 5, 3)
    >>> transaction.commit()
    >>> p.args
    [5, 3]
    >>> p.kwargs
    {}
    >>> p.kwargs['third'] = 2
    >>> p()
    30

This can allow wrapped callables to have a reference to the partial
itself.

    >>> def show(v):
    ...     print v
    ...
    >>> p = root['p'] = zc.async.partial.Partial(show)
    >>> transaction.commit()
    >>> p.args.append(p)
    >>> res = p() # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>

A class method on Partial, `bind`, can simplify this.  It puts the partial as
the first argument to the callable, as if the callable were bound as a method
on the partial.

    >>> p = root['p'] = zc.async.partial.Partial.bind(show)
    >>> transaction.commit()
    >>> res = p() # doctest: +ELLIPSIS
    <zc.async.partial.Partial object at ...>

Result and State
----------------

Partials know about their state, and after a successful call also know
their result, whether it is a Failure or another value.  Possible states are
the constants in zc.async.interfaces named PENDING, ACTIVE, CALLBACKS, and
COMPLETED.

    >>> def showState(partial, *ignore):
    ...     state = partial.state
    ...     for nm in 'PENDING', 'ACTIVE', 'CALLBACKS', 'COMPLETED':
    ...         val = getattr(zc.async.interfaces, nm)
    ...         if state == val:
    ...             print nm
    ...
    >>> p = root['p'] = zc.async.partial.Partial.bind(showState)
    >>> transaction.commit()
    >>> p_callback = p.addCallbacks(zc.async.partial.Partial(showState, p))

    >>> showState(p)
    PENDING
    >>> p.result # None
    >>> res = p()
    ACTIVE
    CALLBACKS
    >>> showState(p)
    COMPLETED

A partial may only be called when the state is PENDING: calling a
partial again raises a BadStateError.

    >>> p()
    Traceback (most recent call last):
    ...
    BadStateError: can only call a partial in PENDING state

Other similar restrictions include the following:

- A partial may not call itself [#call_self]_.

- Also, a partial's direct callback may not call the partial
  [#callback_self]_.

More Partial Introspection
--------------------------

We've already shown that it is possible to introspect unhandled_error,
state, result, args, and kwargs.  Two other aspects of the basic partial
functionality are introspectable: callable and callbacks.

The callable is the callable (function or method of a picklable object) that
the partial will call.  You can change it while the partial is in a pending
state.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 2)
    >>> p.callable is multiply
    True
    >>> p.callable = root['demo'].increase
    >>> p.callable == root['demo'].increase
    True
    >>> transaction.commit()
    >>> root['demo'].counter
    2
    >>> res = p()
    >>> root['demo'].counter
    4

The callbacks are a queue of the callbacks added by addCallbacks (or the
currently experimental and underdocumented addCallback).  Currently the
code may allow for direct mutation of the callbacks, but it is strongly
suggested that you do not mutate the callbacks, especially not adding them
except through addCallbacks or addCallback.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 2, 8)
    >>> len(p.callbacks)
    0
    >>> p_callback = p.addCallbacks(zc.async.partial.Partial(multiply, 5))
    >>> len(p.callbacks)
    1

When you use addCallbacks, you actually get a callback to your callback,
for safety reasons.  Specifically, when you use addCallbacks, the success
and failure callbacks are actually arguments to another callback--the result
of the `addCallbacks` call.  If a worker dies while the partial is in
progress, active argument partials should be cleaned up and will not be
cleaned up automatically with the logic in `resumeCallbacks` (by design:
this may not be desired behavior in all cases).  Therefore we add a callback
to the main callback that does this job.  We return the subsidiary callback
so that error handling is calculated more as expected (see the
`unhandled_error` attribute).

    >>> p.callbacks[0] is p_callback
    False
    >>> p.callbacks[0] is p_callback.__parent__
    True

`addCallback` does not have this characteristic (you are responsible for any
internal partials, therefore).

    >>> p_callback2 = zc.async.partial.Partial(multiply, 9)
    >>> p_callback2 is p.addCallback(p_callback2)
    True

To continue with our example of introspecting the partial...

    >>> len(p.callbacks)
    2
    >>> p.callbacks[1] is p_callback2
    True
    >>> transaction.commit()
    >>> res = p()
    >>> p.result
    16
    >>> p_callback.result
    80
    >>> p_callback2.result
    144
    >>> len(p.callbacks)
    2
    >>> p.callbacks[0] is p_callback.__parent__
    True
    >>> p.callbacks[1] is p_callback2
    True

The __parent__ attribute should hold the immediate parent of a partial. 
This means that a pending partial will be within a data manager's queue;
an active partial will be within a worker's queue (which is within a
worker, which is within a workers container, which is within a data
manager); and a callback will be within another partial (which may be
intermediate to the top level partial, in which case __parent__ of the
intermediate partial is the top level).  Here's an example.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 3, 5)
    >>> p_callback = zc.async.partial.Partial(multiply, 2)
    >>> p_callback2 = p.addCallbacks(p_callback)
    >>> p_callback.__parent__ is p_callback2.__parent__
    True
    >>> p_callback2.__parent__.__parent__ is p
    True
    >>> transaction.abort()

=========
Footnotes
=========

.. [#set_up] We'll actually create the state that the text needs here.

    >>> from ZODB.tests.util import DB
    >>> db = DB()
    >>> conn = db.open()
    >>> root = conn.root()

    You must have two adapter registrations: IConnection to
    ITransactionManager, and IPersistent to IConnection.  We will also
    register IPersistent to ITransactionManager because the adapter is
    designed for it.

    >>> from zc.twist import transactionManager, connection
    >>> import zope.component
    >>> zope.component.provideAdapter(transactionManager)
    >>> zope.component.provideAdapter(connection)
    >>> import ZODB.interfaces
    >>> zope.component.provideAdapter(
    ...     transactionManager, adapts=(ZODB.interfaces.IConnection,))

    The partial class can be registered as an adapter for
    functions and methods.  It needs to be for expected simple usage of
    addCallbacks.

    >>> import zope.component
    >>> import types
    >>> import zc.async.interfaces
    >>> zope.component.provideAdapter(
    ...     zc.async.partial.Partial,
    ...     adapts=(types.FunctionType,),
    ...     provides=zc.async.interfaces.IDataManagerPartial)
    >>> zope.component.provideAdapter(
    ...     zc.async.partial.Partial,
    ...     adapts=(types.MethodType,),
    ...     provides=zc.async.interfaces.IDataManagerPartial)

.. [#verify] Verify interface

    >>> from zope.interface.verify import verifyObject
    >>> verifyObject(zc.async.interfaces.IPartial, p)
    True
    
    Note that state and result are readonly.
    
    >>> p.state = 1
    Traceback (most recent call last):
    ...
    AttributeError: can't set attribute
    >>> p.result = 1
    Traceback (most recent call last):
    ...
    AttributeError: can't set attribute

.. [#no_live_frames] Failures have two particularly dangerous bits: the
    traceback and the stack.  We use the __getstate__ code on Failures
    to clean them up.  This makes the traceback (`tb`) None...
    
    >>> p.result.tb # None
    
    ...and it makes all of the values in the stack--the locals and
    globals-- into strings.  The stack is a list of lists, in which each
    internal list represents a frame, and contains five elements: the
    code name (`f_code.co_name`), the code file (`f_code.co_filename`),
    the line number (`f_lineno`), an items list of the locals, and an
    items list for the globals.  All of the values in the items list
    would normally be objects, but are now strings.
    
    >>> for (codename, filename, lineno, local_i, global_i) in p.result.stack:
    ...     for k, v in local_i:
    ...         assert isinstance(v, basestring), 'bad local %s' % (v,)
    ...     for k, v in global_i:
    ...         assert isinstance(v, basestring), 'bad global %s' % (v,)
    ...
    
    Here's a reasonable question.  The Twisted Failure code has a
    __getstate__ that cleans up the failure, and that's even what we are
    using to sanitize the failure.  If the failure is attached to a
    partial and stored in the ZODB, it is going to be cleaned up anyway.
     Why explicitly clean up the failure even before it is pickled?

    The answer might be classified as paranoia.  Just in case the failure
    is kept around in memory longer--by being put on a deferred, or somehow
    otherwise passed around--we want to eliminate any references to objects
    in the connection as soon as possible.

    Unfortunately, the __getstate__ code in the Twisted Failure can cause
    some interaction problems for code that has a __repr__ with side effects--
    like xmlrpclib, unfortunately.  The `twist` module has a monkeypatch
    for that particular problem, thanks to Florent Guillaume at Nuxeo, but
    others may be discovered.

.. [#explicit_failure_example] As the main text describes, if a call raises
    an exception, the partial will abort the transaction; but if it
    returns a failure explicitly, the call is responsible for making any
    desired changes to the transaction (such as aborting) before the
    partial calls commit.  Compare.  Here is a call that raises an
    exception, and rolls back changes.
    
    (Note that we are passing arguments to the partial, a topic that has
    not yet been discussed in the text when this footnote is given: read
    on a bit in the main text to see the details, if it seems surprising
    or confusing.)

    >>> def callAndRaise(ob):
    ...     ob.increase()
    ...     print ob.counter
    ...     raise RuntimeError
    ...
    >>> p = root['raise_exception_example'] = zc.async.partial.Partial(
    ...     callAndRaise, root['demo'])
    >>> transaction.commit()
    >>> root['demo'].counter
    1
    >>> res = p() # this shows the result of the print in `callAndRaise` above.
    2
    >>> root['demo'].counter # it was rolled back
    1
    >>> print p.result.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    exceptions.RuntimeError:

    Here is a call that returns a failure, and does not abort, even though
    the partial result looks very similar.

    >>> import twisted.python.failure
    >>> def returnExplicitFailure(ob):
    ...     ob.increase()
    ...     try:
    ...         raise RuntimeError
    ...     except RuntimeError:
    ...         # we could have just made and returned a failure without the
    ...         # try/except, but this is intended to make crystal clear that
    ...         # exceptions are irrelevant if you catch them and return a
    ...         # failure
    ...         return twisted.python.failure.Failure()
    ...
    >>> p = root['explicit_failure_example'] = zc.async.partial.Partial(
    ...     returnExplicitFailure, root['demo'])
    >>> transaction.commit()
    >>> res = p()
    >>> root['demo'].counter # it was not rolled back automatically
    2
    >>> print p.result.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    exceptions.RuntimeError:

.. [#call_self] Here's a partial trying to call itself.

    >>> def call(obj, *ignore):
    ...     return obj()
    ...
    >>> p = root['p'] = zc.async.partial.Partial.bind(call)
    >>> transaction.commit()
    >>> res = p()
    >>> print p.result.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    zc.async.interfaces.BadStateError: can only call a partial in PENDING state

.. [#callback_self] Here's a partial's callback trying to call the partial.

    >>> p = root['p'] = zc.async.partial.Partial(multiply, 3, 4)
    >>> p_callback = p.addCallbacks(
    ...     zc.async.partial.Partial(call, p)).addCallbacks(failure=failure)
    >>> transaction.commit()
    >>> res = p() # doctest: +ELLIPSIS
    failure. [Failure instance: Traceback: zc.async.interfaces.BadStateError...]
    >>> p.result # the main partial still ran to completion
    12
